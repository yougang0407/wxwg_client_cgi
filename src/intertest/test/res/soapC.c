/* soapC.c
   Generated by gSOAP 2.8.71 for res.h

gSOAP XML Web services tools
Copyright (C) 2000-2018, Robert van Engelen, Genivia Inc. All Rights Reserved.
The soapcpp2 tool and its generated software are released under the GPL.
This program is released under the GPL with the additional exemption that
compiling, linking, and/or using OpenSSL is allowed.
--------------------------------------------------------------------------------
A commercial use license is available from Genivia Inc., contact@genivia.com
--------------------------------------------------------------------------------
*/

#if defined(__BORLANDC__)
#pragma option push -w-8060
#pragma option push -w-8004
#endif

#include "soapH.h"

#ifdef __cplusplus
extern "C" {
#endif

SOAP_SOURCE_STAMP("@(#) soapC.c ver 2.8.71 2020-11-26 17:53:12 GMT")


#ifndef WITH_NOGLOBAL

SOAP_FMAC3 int SOAP_FMAC4 soap_getheader(struct soap *soap)
{
	soap->part = SOAP_IN_HEADER;
	soap->header = soap_in_SOAP_ENV__Header(soap, "SOAP-ENV:Header", soap->header, NULL);
	soap->part = SOAP_END_HEADER;
	return soap->header == NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putheader(struct soap *soap)
{
	if (soap->version && soap->header)
	{	soap->part = SOAP_IN_HEADER;
		if (soap_out_SOAP_ENV__Header(soap, "SOAP-ENV:Header", 0, soap->header, ""))
			return soap->error;
		soap->part = SOAP_END_HEADER;
	}
	return SOAP_OK;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializeheader(struct soap *soap)
{
	if (soap->version && soap->header)
		soap_serialize_SOAP_ENV__Header(soap, soap->header);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_header(struct soap *soap)
{
	if (soap->header == NULL)
	{	if ((soap->header = (struct SOAP_ENV__Header*)soap_malloc(soap, sizeof(struct SOAP_ENV__Header))))
			soap_default_SOAP_ENV__Header(soap, soap->header);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_fault(struct soap *soap)
{
	if (soap->fault == NULL)
	{	soap->fault = (struct SOAP_ENV__Fault*)soap_malloc(soap, sizeof(struct SOAP_ENV__Fault));
		if (soap->fault == NULL)
			return;
		soap_default_SOAP_ENV__Fault(soap, soap->fault);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Code)
	{	soap->fault->SOAP_ENV__Code = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
		soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code);
	}
	if (soap->version == 2 && !soap->fault->SOAP_ENV__Reason)
	{	soap->fault->SOAP_ENV__Reason = (struct SOAP_ENV__Reason*)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason));
		soap_default_SOAP_ENV__Reason(soap, soap->fault->SOAP_ENV__Reason);
	}
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serializefault(struct soap *soap)
{
	if (soap->fault)
		soap_serialize_SOAP_ENV__Fault(soap, soap->fault);
}

SOAP_FMAC3 int SOAP_FMAC4 soap_putfault(struct soap *soap)
{
	if (soap->fault)
		return soap_put_SOAP_ENV__Fault(soap, soap->fault, "SOAP-ENV:Fault", "");
	return SOAP_OK;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_getfault(struct soap *soap)
{
	return (soap->fault = soap_get_SOAP_ENV__Fault(soap, NULL, "SOAP-ENV:Fault", NULL)) == NULL;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Code)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Value;
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultsubcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode == NULL)
		{	soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode = (struct SOAP_ENV__Code*)soap_malloc(soap, sizeof(struct SOAP_ENV__Code));
			soap_default_SOAP_ENV__Code(soap, soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
	}
	return (const char**)(void*)&soap->fault->faultcode;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_subcode(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Code && soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode)
			return soap->fault->SOAP_ENV__Code->SOAP_ENV__Subcode->SOAP_ENV__Value;
		return NULL;
	}
	return soap->fault->faultcode;
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultstring(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
		return (const char**)(void*)&soap->fault->SOAP_ENV__Reason->SOAP_ENV__Text;
	return (const char**)(void*)&soap->fault->faultstring;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_string(struct soap *soap)
{
	return *soap_faultstring(soap);
}

SOAP_FMAC3 const char ** SOAP_FMAC4 soap_faultdetail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2)
	{	if (soap->fault->SOAP_ENV__Detail == NULL)
		{	soap->fault->SOAP_ENV__Detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
			soap_default_SOAP_ENV__Detail(soap, soap->fault->SOAP_ENV__Detail);
		}
		return (const char**)(void*)&soap->fault->SOAP_ENV__Detail->__any;
	}
	if (soap->fault->detail == NULL)
	{	soap->fault->detail = (struct SOAP_ENV__Detail*)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail));
		soap_default_SOAP_ENV__Detail(soap, soap->fault->detail);
	}
	return (const char**)(void*)&soap->fault->detail->__any;
}

SOAP_FMAC3 const char * SOAP_FMAC4 soap_fault_detail(struct soap *soap)
{
	soap_fault(soap);
	if (soap->version == 2 && soap->fault->SOAP_ENV__Detail)
		return soap->fault->SOAP_ENV__Detail->__any;
	if (soap->fault->detail)
		return soap->fault->detail->__any;
	return NULL;
}

#endif

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_getindependent(struct soap *soap)
{
	int t;
	if (soap->version == 1)
	{	for (;;)
		{	if (!soap_getelement(soap, &t))
				if ((soap->error && soap->error != SOAP_TAG_MISMATCH) || soap_ignore_element(soap))
					break;
		}
	}
	if (soap->error == SOAP_NO_TAG || soap->error == SOAP_EOF)
		soap->error = SOAP_OK;
	return soap->error;
}
#endif
SOAP_FMAC3 void * SOAP_FMAC4 soap_getelement(struct soap *soap, int *type)
{	(void)type;
	if (soap_peek_element(soap))
		return NULL;
#ifndef WITH_NOIDREF
	if (!*soap->id || !(*type = soap_lookup_type(soap, soap->id)))
		*type = soap_lookup_type(soap, soap->href);
	switch (*type)
	{
	case SOAP_TYPE_byte:
		return soap_in_byte(soap, NULL, NULL, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_in_int(soap, NULL, NULL, "xsd:int");
	case SOAP_TYPE_ns1__DataModify:
		return soap_in_ns1__DataModify(soap, NULL, NULL, "ns1:DataModify");
	case SOAP_TYPE_ns1__DataModifyResponse:
		return soap_in_ns1__DataModifyResponse(soap, NULL, NULL, "ns1:DataModifyResponse");
	case SOAP_TYPE_ns1__DataCancel:
		return soap_in_ns1__DataCancel(soap, NULL, NULL, "ns1:DataCancel");
	case SOAP_TYPE_ns1__DataCancelResponse:
		return soap_in_ns1__DataCancelResponse(soap, NULL, NULL, "ns1:DataCancelResponse");
	case SOAP_TYPE_ns1__SoftModify:
		return soap_in_ns1__SoftModify(soap, NULL, NULL, "ns1:SoftModify");
	case SOAP_TYPE_ns1__SoftModifyResponse:
		return soap_in_ns1__SoftModifyResponse(soap, NULL, NULL, "ns1:SoftModifyResponse");
	case SOAP_TYPE_ns1__SoftCancel:
		return soap_in_ns1__SoftCancel(soap, NULL, NULL, "ns1:SoftCancel");
	case SOAP_TYPE_ns1__SoftCancelResponse:
		return soap_in_ns1__SoftCancelResponse(soap, NULL, NULL, "ns1:SoftCancelResponse");
	case SOAP_TYPE_ns1__DeviceListGet:
		return soap_in_ns1__DeviceListGet(soap, NULL, NULL, "ns1:DeviceListGet");
	case SOAP_TYPE_ns1__DeviceListGetResponse:
		return soap_in_ns1__DeviceListGetResponse(soap, NULL, NULL, "ns1:DeviceListGetResponse");
	case SOAP_TYPE_ns1__DeviceModify:
		return soap_in_ns1__DeviceModify(soap, NULL, NULL, "ns1:DeviceModify");
	case SOAP_TYPE_ns1__DeviceModifyResponse:
		return soap_in_ns1__DeviceModifyResponse(soap, NULL, NULL, "ns1:DeviceModifyResponse");
	case SOAP_TYPE_ns1__DeviceCancel:
		return soap_in_ns1__DeviceCancel(soap, NULL, NULL, "ns1:DeviceCancel");
	case SOAP_TYPE_ns1__DeviceCancelResponse:
		return soap_in_ns1__DeviceCancelResponse(soap, NULL, NULL, "ns1:DeviceCancelResponse");
	case SOAP_TYPE_ns1__DataDefine:
		return soap_in_ns1__DataDefine(soap, NULL, NULL, "ns1:DataDefine");
	case SOAP_TYPE_ns1__DataDefineResponse:
		return soap_in_ns1__DataDefineResponse(soap, NULL, NULL, "ns1:DataDefineResponse");
	case SOAP_TYPE_ns1__DataListGet:
		return soap_in_ns1__DataListGet(soap, NULL, NULL, "ns1:DataListGet");
	case SOAP_TYPE_ns1__DataListGetResponse:
		return soap_in_ns1__DataListGetResponse(soap, NULL, NULL, "ns1:DataListGetResponse");
	case SOAP_TYPE_ns1__Challenge:
		return soap_in_ns1__Challenge(soap, NULL, NULL, "ns1:Challenge");
	case SOAP_TYPE_ns1__ChallengeResponse:
		return soap_in_ns1__ChallengeResponse(soap, NULL, NULL, "ns1:ChallengeResponse");
	case SOAP_TYPE_ns1__SoftDefine:
		return soap_in_ns1__SoftDefine(soap, NULL, NULL, "ns1:SoftDefine");
	case SOAP_TYPE_ns1__SoftDefineResponse:
		return soap_in_ns1__SoftDefineResponse(soap, NULL, NULL, "ns1:SoftDefineResponse");
	case SOAP_TYPE_ns1__SoftListGet:
		return soap_in_ns1__SoftListGet(soap, NULL, NULL, "ns1:SoftListGet");
	case SOAP_TYPE_ns1__SoftListGetResponse:
		return soap_in_ns1__SoftListGetResponse(soap, NULL, NULL, "ns1:SoftListGetResponse");
	case SOAP_TYPE_ns1__DeviceDefine:
		return soap_in_ns1__DeviceDefine(soap, NULL, NULL, "ns1:DeviceDefine");
	case SOAP_TYPE_ns1__DeviceDefineResponse:
		return soap_in_ns1__DeviceDefineResponse(soap, NULL, NULL, "ns1:DeviceDefineResponse");
	case SOAP_TYPE_ns1__addDeviceBatch:
		return soap_in_ns1__addDeviceBatch(soap, NULL, NULL, "ns1:addDeviceBatch");
	case SOAP_TYPE_ns1__addDeviceBatchResponse:
		return soap_in_ns1__addDeviceBatchResponse(soap, NULL, NULL, "ns1:addDeviceBatchResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_in_PointerTostring(soap, NULL, NULL, "xsd:string");
	case SOAP_TYPE__QName:
	{	char **s;
		s = soap_in__QName(soap, NULL, NULL, "xsd:QName");
		return s ? *s : NULL;
	}
	case SOAP_TYPE_string:
	{	char **s;
		s = soap_in_string(soap, NULL, NULL, "xsd:string");
		return s ? *s : NULL;
	}
	default:
#else
	*type = 0;
#endif
	{	const char *t = soap->type;
		if (!*t)
			t = soap->tag;
		if (!soap_match_tag(soap, t, "xsd:byte"))
		{	*type = SOAP_TYPE_byte;
			return soap_in_byte(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:int"))
		{	*type = SOAP_TYPE_int;
			return soap_in_int(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataModify"))
		{	*type = SOAP_TYPE_ns1__DataModify;
			return soap_in_ns1__DataModify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataModifyResponse"))
		{	*type = SOAP_TYPE_ns1__DataModifyResponse;
			return soap_in_ns1__DataModifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataCancel"))
		{	*type = SOAP_TYPE_ns1__DataCancel;
			return soap_in_ns1__DataCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataCancelResponse"))
		{	*type = SOAP_TYPE_ns1__DataCancelResponse;
			return soap_in_ns1__DataCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftModify"))
		{	*type = SOAP_TYPE_ns1__SoftModify;
			return soap_in_ns1__SoftModify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftModifyResponse"))
		{	*type = SOAP_TYPE_ns1__SoftModifyResponse;
			return soap_in_ns1__SoftModifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftCancel"))
		{	*type = SOAP_TYPE_ns1__SoftCancel;
			return soap_in_ns1__SoftCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftCancelResponse"))
		{	*type = SOAP_TYPE_ns1__SoftCancelResponse;
			return soap_in_ns1__SoftCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceListGet"))
		{	*type = SOAP_TYPE_ns1__DeviceListGet;
			return soap_in_ns1__DeviceListGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceListGetResponse"))
		{	*type = SOAP_TYPE_ns1__DeviceListGetResponse;
			return soap_in_ns1__DeviceListGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceModify"))
		{	*type = SOAP_TYPE_ns1__DeviceModify;
			return soap_in_ns1__DeviceModify(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceModifyResponse"))
		{	*type = SOAP_TYPE_ns1__DeviceModifyResponse;
			return soap_in_ns1__DeviceModifyResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceCancel"))
		{	*type = SOAP_TYPE_ns1__DeviceCancel;
			return soap_in_ns1__DeviceCancel(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceCancelResponse"))
		{	*type = SOAP_TYPE_ns1__DeviceCancelResponse;
			return soap_in_ns1__DeviceCancelResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataDefine"))
		{	*type = SOAP_TYPE_ns1__DataDefine;
			return soap_in_ns1__DataDefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataDefineResponse"))
		{	*type = SOAP_TYPE_ns1__DataDefineResponse;
			return soap_in_ns1__DataDefineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataListGet"))
		{	*type = SOAP_TYPE_ns1__DataListGet;
			return soap_in_ns1__DataListGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DataListGetResponse"))
		{	*type = SOAP_TYPE_ns1__DataListGetResponse;
			return soap_in_ns1__DataListGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:Challenge"))
		{	*type = SOAP_TYPE_ns1__Challenge;
			return soap_in_ns1__Challenge(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:ChallengeResponse"))
		{	*type = SOAP_TYPE_ns1__ChallengeResponse;
			return soap_in_ns1__ChallengeResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftDefine"))
		{	*type = SOAP_TYPE_ns1__SoftDefine;
			return soap_in_ns1__SoftDefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftDefineResponse"))
		{	*type = SOAP_TYPE_ns1__SoftDefineResponse;
			return soap_in_ns1__SoftDefineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftListGet"))
		{	*type = SOAP_TYPE_ns1__SoftListGet;
			return soap_in_ns1__SoftListGet(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:SoftListGetResponse"))
		{	*type = SOAP_TYPE_ns1__SoftListGetResponse;
			return soap_in_ns1__SoftListGetResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceDefine"))
		{	*type = SOAP_TYPE_ns1__DeviceDefine;
			return soap_in_ns1__DeviceDefine(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:DeviceDefineResponse"))
		{	*type = SOAP_TYPE_ns1__DeviceDefineResponse;
			return soap_in_ns1__DeviceDefineResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceBatch"))
		{	*type = SOAP_TYPE_ns1__addDeviceBatch;
			return soap_in_ns1__addDeviceBatch(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "ns1:addDeviceBatchResponse"))
		{	*type = SOAP_TYPE_ns1__addDeviceBatchResponse;
			return soap_in_ns1__addDeviceBatchResponse(soap, NULL, NULL, NULL);
		}
		if (!soap_match_tag(soap, t, "xsd:QName"))
		{	char **s;
			*type = SOAP_TYPE__QName;
			s = soap_in__QName(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		if (!soap_match_tag(soap, t, "xsd:string"))
		{	char **s;
			*type = SOAP_TYPE_string;
			s = soap_in_string(soap, NULL, NULL, NULL);
			return s ? *s : NULL;
		}
		t = soap->tag;
#ifndef WITH_NOIDREF
	}
#endif
	}
	soap->error = SOAP_TAG_MISMATCH;
	return NULL;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_ignore_element(struct soap *soap)
{
	if (!soap_peek_element(soap))
	{	int t;
		DBGLOG(TEST, SOAP_MESSAGE(fdebug, "Unexpected element '%s' in input (level = %u, %d)\n", soap->tag, soap->level, soap->body));
		if (soap->mustUnderstand && !soap->other && !soap->fignore)
			return soap->error = SOAP_MUSTUNDERSTAND;
		if (((soap->mode & SOAP_XML_STRICT) && !soap->fignore && soap->part != SOAP_IN_HEADER) || !soap_match_tag(soap, soap->tag, "SOAP-ENV:"))
		{	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "REJECTING element '%s'\n", soap->tag));
			return soap->error = SOAP_TAG_MISMATCH;
		}
		if (!*soap->id || !soap_getelement(soap, &t))
		{	soap->peeked = 0;
			if (soap->fignore)
				soap->error = soap->fignore(soap, soap->tag);
			else
				soap->error = SOAP_OK;
			DBGLOG(TEST, if (!soap->error) SOAP_MESSAGE(fdebug, "IGNORING element '%s'\n", soap->tag));
			if (!soap->error && soap->body && soap_ignore(soap))
				return soap->error;
		}
	}
	return soap->error;
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 int SOAP_FMAC4 soap_putindependent(struct soap *soap)
{
	int i;
	struct soap_plist *pp;
	if (soap->version == 1 && soap->encodingStyle && !(soap->mode & (SOAP_XML_TREE | SOAP_XML_GRAPH)))
		for (i = 0; i < SOAP_PTRHASH; i++)
			for (pp = soap->pht[i]; pp; pp = pp->next)
				if (pp->mark1 == 2 || pp->mark2 == 2)
					if (soap_putelement(soap, pp->ptr, SOAP_MULTIREFTAG, pp->id, pp->type))
						return soap->error;
	return SOAP_OK;
}
#endif
SOAP_FMAC3 int SOAP_FMAC4 soap_putelement(struct soap *soap, const void *ptr, const char *tag, int id, int type)
{	(void)tag;
	switch (type)
	{
	case SOAP_TYPE_byte:
		return soap_out_byte(soap, tag, id, (const char *)ptr, "xsd:byte");
	case SOAP_TYPE_int:
		return soap_out_int(soap, tag, id, (const int *)ptr, "xsd:int");
	case SOAP_TYPE_ns1__DataModify:
		return soap_out_ns1__DataModify(soap, tag, id, (const struct ns1__DataModify *)ptr, "ns1:DataModify");
	case SOAP_TYPE_ns1__DataModifyResponse:
		return soap_out_ns1__DataModifyResponse(soap, tag, id, (const struct ns1__DataModifyResponse *)ptr, "ns1:DataModifyResponse");
	case SOAP_TYPE_ns1__DataCancel:
		return soap_out_ns1__DataCancel(soap, tag, id, (const struct ns1__DataCancel *)ptr, "ns1:DataCancel");
	case SOAP_TYPE_ns1__DataCancelResponse:
		return soap_out_ns1__DataCancelResponse(soap, tag, id, (const struct ns1__DataCancelResponse *)ptr, "ns1:DataCancelResponse");
	case SOAP_TYPE_ns1__SoftModify:
		return soap_out_ns1__SoftModify(soap, tag, id, (const struct ns1__SoftModify *)ptr, "ns1:SoftModify");
	case SOAP_TYPE_ns1__SoftModifyResponse:
		return soap_out_ns1__SoftModifyResponse(soap, tag, id, (const struct ns1__SoftModifyResponse *)ptr, "ns1:SoftModifyResponse");
	case SOAP_TYPE_ns1__SoftCancel:
		return soap_out_ns1__SoftCancel(soap, tag, id, (const struct ns1__SoftCancel *)ptr, "ns1:SoftCancel");
	case SOAP_TYPE_ns1__SoftCancelResponse:
		return soap_out_ns1__SoftCancelResponse(soap, tag, id, (const struct ns1__SoftCancelResponse *)ptr, "ns1:SoftCancelResponse");
	case SOAP_TYPE_ns1__DeviceListGet:
		return soap_out_ns1__DeviceListGet(soap, tag, id, (const struct ns1__DeviceListGet *)ptr, "ns1:DeviceListGet");
	case SOAP_TYPE_ns1__DeviceListGetResponse:
		return soap_out_ns1__DeviceListGetResponse(soap, tag, id, (const struct ns1__DeviceListGetResponse *)ptr, "ns1:DeviceListGetResponse");
	case SOAP_TYPE_ns1__DeviceModify:
		return soap_out_ns1__DeviceModify(soap, tag, id, (const struct ns1__DeviceModify *)ptr, "ns1:DeviceModify");
	case SOAP_TYPE_ns1__DeviceModifyResponse:
		return soap_out_ns1__DeviceModifyResponse(soap, tag, id, (const struct ns1__DeviceModifyResponse *)ptr, "ns1:DeviceModifyResponse");
	case SOAP_TYPE_ns1__DeviceCancel:
		return soap_out_ns1__DeviceCancel(soap, tag, id, (const struct ns1__DeviceCancel *)ptr, "ns1:DeviceCancel");
	case SOAP_TYPE_ns1__DeviceCancelResponse:
		return soap_out_ns1__DeviceCancelResponse(soap, tag, id, (const struct ns1__DeviceCancelResponse *)ptr, "ns1:DeviceCancelResponse");
	case SOAP_TYPE_ns1__DataDefine:
		return soap_out_ns1__DataDefine(soap, tag, id, (const struct ns1__DataDefine *)ptr, "ns1:DataDefine");
	case SOAP_TYPE_ns1__DataDefineResponse:
		return soap_out_ns1__DataDefineResponse(soap, tag, id, (const struct ns1__DataDefineResponse *)ptr, "ns1:DataDefineResponse");
	case SOAP_TYPE_ns1__DataListGet:
		return soap_out_ns1__DataListGet(soap, tag, id, (const struct ns1__DataListGet *)ptr, "ns1:DataListGet");
	case SOAP_TYPE_ns1__DataListGetResponse:
		return soap_out_ns1__DataListGetResponse(soap, tag, id, (const struct ns1__DataListGetResponse *)ptr, "ns1:DataListGetResponse");
	case SOAP_TYPE_ns1__Challenge:
		return soap_out_ns1__Challenge(soap, tag, id, (const struct ns1__Challenge *)ptr, "ns1:Challenge");
	case SOAP_TYPE_ns1__ChallengeResponse:
		return soap_out_ns1__ChallengeResponse(soap, tag, id, (const struct ns1__ChallengeResponse *)ptr, "ns1:ChallengeResponse");
	case SOAP_TYPE_ns1__SoftDefine:
		return soap_out_ns1__SoftDefine(soap, tag, id, (const struct ns1__SoftDefine *)ptr, "ns1:SoftDefine");
	case SOAP_TYPE_ns1__SoftDefineResponse:
		return soap_out_ns1__SoftDefineResponse(soap, tag, id, (const struct ns1__SoftDefineResponse *)ptr, "ns1:SoftDefineResponse");
	case SOAP_TYPE_ns1__SoftListGet:
		return soap_out_ns1__SoftListGet(soap, tag, id, (const struct ns1__SoftListGet *)ptr, "ns1:SoftListGet");
	case SOAP_TYPE_ns1__SoftListGetResponse:
		return soap_out_ns1__SoftListGetResponse(soap, tag, id, (const struct ns1__SoftListGetResponse *)ptr, "ns1:SoftListGetResponse");
	case SOAP_TYPE_ns1__DeviceDefine:
		return soap_out_ns1__DeviceDefine(soap, tag, id, (const struct ns1__DeviceDefine *)ptr, "ns1:DeviceDefine");
	case SOAP_TYPE_ns1__DeviceDefineResponse:
		return soap_out_ns1__DeviceDefineResponse(soap, tag, id, (const struct ns1__DeviceDefineResponse *)ptr, "ns1:DeviceDefineResponse");
	case SOAP_TYPE_ns1__addDeviceBatch:
		return soap_out_ns1__addDeviceBatch(soap, tag, id, (const struct ns1__addDeviceBatch *)ptr, "ns1:addDeviceBatch");
	case SOAP_TYPE_ns1__addDeviceBatchResponse:
		return soap_out_ns1__addDeviceBatchResponse(soap, tag, id, (const struct ns1__addDeviceBatchResponse *)ptr, "ns1:addDeviceBatchResponse");
	case SOAP_TYPE_PointerTostring:
		return soap_out_PointerTostring(soap, tag, id, (char **const*)ptr, "xsd:string");
	case SOAP_TYPE__QName:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:QName");
	case SOAP_TYPE_string:
		return soap_out_string(soap, tag, id, (char*const*)(void*)&ptr, "xsd:string");
	case 0:
		return SOAP_OK;
	}
	DBGLOG(TEST, SOAP_MESSAGE(fdebug, "soap_putelement '%s' failed for type %d in soapC.c\n", tag ? tag : "", type));
	return soap_element_empty(soap, tag); /* unknown type to serialize */
}

#ifndef WITH_NOIDREF
SOAP_FMAC3 void SOAP_FMAC4 soap_markelement(struct soap *soap, const void *ptr, int type)
{
	(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	switch (type)
	{
	case SOAP_TYPE_ns1__DataModify:
		soap_serialize_ns1__DataModify(soap, (const struct ns1__DataModify *)ptr);
		break;
	case SOAP_TYPE_ns1__DataModifyResponse:
		soap_serialize_ns1__DataModifyResponse(soap, (const struct ns1__DataModifyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DataCancel:
		soap_serialize_ns1__DataCancel(soap, (const struct ns1__DataCancel *)ptr);
		break;
	case SOAP_TYPE_ns1__DataCancelResponse:
		soap_serialize_ns1__DataCancelResponse(soap, (const struct ns1__DataCancelResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftModify:
		soap_serialize_ns1__SoftModify(soap, (const struct ns1__SoftModify *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftModifyResponse:
		soap_serialize_ns1__SoftModifyResponse(soap, (const struct ns1__SoftModifyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftCancel:
		soap_serialize_ns1__SoftCancel(soap, (const struct ns1__SoftCancel *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftCancelResponse:
		soap_serialize_ns1__SoftCancelResponse(soap, (const struct ns1__SoftCancelResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceListGet:
		soap_serialize_ns1__DeviceListGet(soap, (const struct ns1__DeviceListGet *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceListGetResponse:
		soap_serialize_ns1__DeviceListGetResponse(soap, (const struct ns1__DeviceListGetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceModify:
		soap_serialize_ns1__DeviceModify(soap, (const struct ns1__DeviceModify *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceModifyResponse:
		soap_serialize_ns1__DeviceModifyResponse(soap, (const struct ns1__DeviceModifyResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceCancel:
		soap_serialize_ns1__DeviceCancel(soap, (const struct ns1__DeviceCancel *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceCancelResponse:
		soap_serialize_ns1__DeviceCancelResponse(soap, (const struct ns1__DeviceCancelResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DataDefine:
		soap_serialize_ns1__DataDefine(soap, (const struct ns1__DataDefine *)ptr);
		break;
	case SOAP_TYPE_ns1__DataDefineResponse:
		soap_serialize_ns1__DataDefineResponse(soap, (const struct ns1__DataDefineResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DataListGet:
		soap_serialize_ns1__DataListGet(soap, (const struct ns1__DataListGet *)ptr);
		break;
	case SOAP_TYPE_ns1__DataListGetResponse:
		soap_serialize_ns1__DataListGetResponse(soap, (const struct ns1__DataListGetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__Challenge:
		soap_serialize_ns1__Challenge(soap, (const struct ns1__Challenge *)ptr);
		break;
	case SOAP_TYPE_ns1__ChallengeResponse:
		soap_serialize_ns1__ChallengeResponse(soap, (const struct ns1__ChallengeResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftDefine:
		soap_serialize_ns1__SoftDefine(soap, (const struct ns1__SoftDefine *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftDefineResponse:
		soap_serialize_ns1__SoftDefineResponse(soap, (const struct ns1__SoftDefineResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftListGet:
		soap_serialize_ns1__SoftListGet(soap, (const struct ns1__SoftListGet *)ptr);
		break;
	case SOAP_TYPE_ns1__SoftListGetResponse:
		soap_serialize_ns1__SoftListGetResponse(soap, (const struct ns1__SoftListGetResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceDefine:
		soap_serialize_ns1__DeviceDefine(soap, (const struct ns1__DeviceDefine *)ptr);
		break;
	case SOAP_TYPE_ns1__DeviceDefineResponse:
		soap_serialize_ns1__DeviceDefineResponse(soap, (const struct ns1__DeviceDefineResponse *)ptr);
		break;
	case SOAP_TYPE_ns1__addDeviceBatch:
		soap_serialize_ns1__addDeviceBatch(soap, (const struct ns1__addDeviceBatch *)ptr);
		break;
	case SOAP_TYPE_ns1__addDeviceBatchResponse:
		soap_serialize_ns1__addDeviceBatchResponse(soap, (const struct ns1__addDeviceBatchResponse *)ptr);
		break;
	case SOAP_TYPE_PointerTostring:
		soap_serialize_PointerTostring(soap, (char **const*)ptr);
		break;
	case SOAP_TYPE__QName:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	case SOAP_TYPE_string:
		soap_serialize_string(soap, (char*const*)(void*)&ptr);
		break;
	}
}
#endif

SOAP_FMAC3 void * SOAP_FMAC4 soap_dupelement(struct soap *soap, const void *ptr, int type)
{(void)soap; (void)ptr; (void)type; /* appease -Wall -Werror */
	return NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_delelement(const void *ptr, int type)
{(void)ptr; (void)type; /* appease -Wall -Werror */
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_byte(struct soap *soap, const char *tag, int id, const char *a, const char *type)
{
	return soap_outbyte(soap, tag, id, a, type, SOAP_TYPE_byte);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_in_byte(struct soap *soap, const char *tag, char *a, const char *type)
{
	a = soap_inbyte(soap, tag, a, type, SOAP_TYPE_byte);
	return a;
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_new_byte(struct soap *soap, int n)
{
	char *p;
	char *a = (char*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char));
	for (p = a; p && n--; p++)
		soap_default_byte(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_byte(struct soap *soap, const char *a, const char *tag, const char *type)
{
	if (soap_out_byte(soap, tag ? tag : "byte", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char * SOAP_FMAC4 soap_get_byte(struct soap *soap, char *p, const char *tag, const char *type)
{
	if ((p = soap_in_byte(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_int(struct soap *soap, const char *tag, int id, const int *a, const char *type)
{
	return soap_outint(soap, tag, id, a, type, SOAP_TYPE_int);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_in_int(struct soap *soap, const char *tag, int *a, const char *type)
{
	a = soap_inint(soap, tag, a, type, SOAP_TYPE_int);
	return a;
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_new_int(struct soap *soap, int n)
{
	int *p;
	int *a = (int*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(int));
	for (p = a; p && n--; p++)
		soap_default_int(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_int(struct soap *soap, const int *a, const char *tag, const char *type)
{
	if (soap_out_int(soap, tag ? tag : "int", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 int * SOAP_FMAC4 soap_get_int(struct soap *soap, int *p, const char *tag, const char *type)
{
	if ((p = soap_in_int(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->faultcode);
	soap_default_string(soap, &a->faultstring);
	soap_default_string(soap, &a->faultactor);
	a->detail = NULL;
	a->SOAP_ENV__Code = NULL;
	a->SOAP_ENV__Reason = NULL;
	soap_default_string(soap, &a->SOAP_ENV__Node);
	soap_default_string(soap, &a->SOAP_ENV__Role);
	a->SOAP_ENV__Detail = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->faultcode);
	soap_serialize_string(soap, (char*const*)&a->faultstring);
	soap_serialize_string(soap, (char*const*)&a->faultactor);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->detail);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Code);
	soap_serialize_PointerToSOAP_ENV__Reason(soap, &a->SOAP_ENV__Reason);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Node);
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Role);
	soap_serialize_PointerToSOAP_ENV__Detail(soap, &a->SOAP_ENV__Detail);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Fault(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Fault *a, const char *type)
{
	const char *soap_tmp_faultcode = soap_QName2s(soap, a->faultcode);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Fault), type))
		return soap->error;
	if (soap_out__QName(soap, "faultcode", -1, (char*const*)(void*)&soap_tmp_faultcode, ""))
		return soap->error;
	if (soap_out_string(soap, "faultstring", -1, (char*const*)&a->faultstring, ""))
		return soap->error;
	if (soap_out_string(soap, "faultactor", -1, (char*const*)&a->faultactor, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "detail", -1, &a->detail, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", -1, &a->SOAP_ENV__Code, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", -1, &a->SOAP_ENV__Reason, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Node", -1, (char*const*)&a->SOAP_ENV__Node, ""))
		return soap->error;
	if (soap_out_string(soap, "SOAP-ENV:Role", -1, (char*const*)&a->SOAP_ENV__Role, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", -1, &a->SOAP_ENV__Detail, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_in_SOAP_ENV__Fault(struct soap *soap, const char *tag, struct SOAP_ENV__Fault *a, const char *type)
{
	size_t soap_flag_faultcode = 1;
	size_t soap_flag_faultstring = 1;
	size_t soap_flag_faultactor = 1;
	size_t soap_flag_detail = 1;
	size_t soap_flag_SOAP_ENV__Code = 1;
	size_t soap_flag_SOAP_ENV__Reason = 1;
	size_t soap_flag_SOAP_ENV__Node = 1;
	size_t soap_flag_SOAP_ENV__Role = 1;
	size_t soap_flag_SOAP_ENV__Detail = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Fault*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Fault(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_faultcode && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "faultcode", (char**)&a->faultcode, "xsd:QName"))
				{	soap_flag_faultcode--;
					continue;
				}
			}
			if (soap_flag_faultstring && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultstring", (char**)&a->faultstring, "xsd:string"))
				{	soap_flag_faultstring--;
					continue;
				}
			}
			if (soap_flag_faultactor && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "faultactor", (char**)&a->faultactor, "xsd:string"))
				{	soap_flag_faultactor--;
					continue;
				}
			}
			if (soap_flag_detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "detail", &a->detail, ""))
				{	soap_flag_detail--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Code && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Code", &a->SOAP_ENV__Code, ""))
				{	soap_flag_SOAP_ENV__Code--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Reason && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Reason(soap, "SOAP-ENV:Reason", &a->SOAP_ENV__Reason, ""))
				{	soap_flag_SOAP_ENV__Reason--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Node && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Node", (char**)&a->SOAP_ENV__Node, "xsd:string"))
				{	soap_flag_SOAP_ENV__Node--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Role && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Role", (char**)&a->SOAP_ENV__Role, "xsd:string"))
				{	soap_flag_SOAP_ENV__Role--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Detail && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Detail(soap, "SOAP-ENV:Detail", &a->SOAP_ENV__Detail, ""))
				{	soap_flag_SOAP_ENV__Detail--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Fault *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Fault, SOAP_TYPE_SOAP_ENV__Fault, sizeof(struct SOAP_ENV__Fault), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_new_SOAP_ENV__Fault(struct soap *soap, int n)
{
	struct SOAP_ENV__Fault *p;
	struct SOAP_ENV__Fault *a = (struct SOAP_ENV__Fault*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Fault));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Fault(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Fault(struct soap *soap, const struct SOAP_ENV__Fault *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Fault(soap, tag ? tag : "SOAP-ENV:Fault", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Fault * SOAP_FMAC4 soap_get_SOAP_ENV__Fault(struct soap *soap, struct SOAP_ENV__Fault *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Fault(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->SOAP_ENV__Text);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->SOAP_ENV__Text);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Reason(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Reason *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Reason), type))
		return soap->error;
	if (soap->lang)
		soap_set_attr(soap, "xml:lang", soap->lang, 1);
	if (soap_out_string(soap, "SOAP-ENV:Text", -1, (char*const*)&a->SOAP_ENV__Text, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_in_SOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Text = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Reason*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Reason(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Text && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, "SOAP-ENV:Text", (char**)&a->SOAP_ENV__Text, "xsd:string"))
				{	soap_flag_SOAP_ENV__Text--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Reason, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_new_SOAP_ENV__Reason(struct soap *soap, int n)
{
	struct SOAP_ENV__Reason *p;
	struct SOAP_ENV__Reason *a = (struct SOAP_ENV__Reason*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Reason));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Reason(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Reason(struct soap *soap, const struct SOAP_ENV__Reason *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason * SOAP_FMAC4 soap_get_SOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->__any = NULL;
	a->__type = 0;
	a->fault = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_markelement(soap, a->fault, a->__type);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Detail(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Detail *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Detail), type))
		return soap->error;
	if (soap_outliteral(soap, "-any", (char*const*)&a->__any, NULL))
		return soap->error;
	if (soap_putelement(soap, a->fault, "fault", -1, a->__type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_in_SOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail *a, const char *type)
{
	size_t soap_flag___any = 1;
	size_t soap_flag_fault = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Detail*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Detail(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_fault && soap->error == SOAP_TAG_MISMATCH)
			{	if ((a->fault = soap_getelement(soap, &a->__type)))
				{	soap_flag_fault = 0;
					continue;
				}
			}
			if (soap_flag___any && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_inliteral(soap, "-any", (char**)&a->__any))
				{	soap_flag___any--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Detail, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_new_SOAP_ENV__Detail(struct soap *soap, int n)
{
	struct SOAP_ENV__Detail *p;
	struct SOAP_ENV__Detail *a = (struct SOAP_ENV__Detail*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Detail));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Detail(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Detail(struct soap *soap, const struct SOAP_ENV__Detail *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail * SOAP_FMAC4 soap_get_SOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default__QName(soap, &a->SOAP_ENV__Value);
	a->SOAP_ENV__Subcode = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize__QName(soap, (char*const*)&a->SOAP_ENV__Value);
	soap_serialize_PointerToSOAP_ENV__Code(soap, &a->SOAP_ENV__Subcode);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Code(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Code *a, const char *type)
{
	const char *soap_tmp_SOAP_ENV__Value = soap_QName2s(soap, a->SOAP_ENV__Value);
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Code), type))
		return soap->error;
	if (soap_out__QName(soap, "SOAP-ENV:Value", -1, (char*const*)(void*)&soap_tmp_SOAP_ENV__Value, ""))
		return soap->error;
	if (soap_out_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", -1, &a->SOAP_ENV__Subcode, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_in_SOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code *a, const char *type)
{
	size_t soap_flag_SOAP_ENV__Value = 1;
	size_t soap_flag_SOAP_ENV__Subcode = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Code*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Code(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_SOAP_ENV__Value && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in__QName(soap, "SOAP-ENV:Value", (char**)&a->SOAP_ENV__Value, "xsd:QName"))
				{	soap_flag_SOAP_ENV__Value--;
					continue;
				}
			}
			if (soap_flag_SOAP_ENV__Subcode && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerToSOAP_ENV__Code(soap, "SOAP-ENV:Subcode", &a->SOAP_ENV__Subcode, ""))
				{	soap_flag_SOAP_ENV__Subcode--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Code, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_new_SOAP_ENV__Code(struct soap *soap, int n)
{
	struct SOAP_ENV__Code *p;
	struct SOAP_ENV__Code *a = (struct SOAP_ENV__Code*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Code));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Code(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Code(struct soap *soap, const struct SOAP_ENV__Code *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code * SOAP_FMAC4 soap_get_SOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_default_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_SOAP_ENV__Header(struct soap *soap, const char *tag, int id, const struct SOAP_ENV__Header *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_SOAP_ENV__Header), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_in_SOAP_ENV__Header(struct soap *soap, const char *tag, struct SOAP_ENV__Header *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct SOAP_ENV__Header*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_SOAP_ENV__Header(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Header *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_SOAP_ENV__Header, SOAP_TYPE_SOAP_ENV__Header, sizeof(struct SOAP_ENV__Header), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_new_SOAP_ENV__Header(struct soap *soap, int n)
{
	struct SOAP_ENV__Header *p;
	struct SOAP_ENV__Header *a = (struct SOAP_ENV__Header*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct SOAP_ENV__Header));
	for (p = a; p && n--; p++)
		soap_default_SOAP_ENV__Header(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_SOAP_ENV__Header(struct soap *soap, const struct SOAP_ENV__Header *a, const char *tag, const char *type)
{
	if (soap_out_SOAP_ENV__Header(soap, tag ? tag : "SOAP-ENV:Header", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Header * SOAP_FMAC4 soap_get_SOAP_ENV__Header(struct soap *soap, struct SOAP_ENV__Header *p, const char *tag, const char *type)
{
	if ((p = soap_in_SOAP_ENV__Header(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataModify(struct soap *soap, struct ns1__DataModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataModify(struct soap *soap, const struct ns1__DataModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataModify(struct soap *soap, const char *tag, int id, const struct ns1__DataModify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataModify), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataModify * SOAP_FMAC4 soap_in_ns1__DataModify(struct soap *soap, const char *tag, struct ns1__DataModify *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataModify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataModify, sizeof(struct ns1__DataModify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataModify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataModify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataModify, SOAP_TYPE_ns1__DataModify, sizeof(struct ns1__DataModify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataModify * SOAP_FMAC4 soap_new_ns1__DataModify(struct soap *soap, int n)
{
	struct ns1__DataModify *p;
	struct ns1__DataModify *a = (struct ns1__DataModify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataModify));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataModify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataModify(struct soap *soap, const struct ns1__DataModify *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataModify(soap, tag ? tag : "ns1:DataModify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataModify * SOAP_FMAC4 soap_get_ns1__DataModify(struct soap *soap, struct ns1__DataModify *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataModify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataModifyResponse(struct soap *soap, struct ns1__DataModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DataModifyReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataModifyResponse(struct soap *soap, const struct ns1__DataModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DataModifyReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataModifyResponse(struct soap *soap, const char *tag, int id, const struct ns1__DataModifyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataModifyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DataModifyReturn", -1, &a->_DataModifyReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataModifyResponse * SOAP_FMAC4 soap_in_ns1__DataModifyResponse(struct soap *soap, const char *tag, struct ns1__DataModifyResponse *a, const char *type)
{
	size_t soap_flag__DataModifyReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataModifyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataModifyResponse, sizeof(struct ns1__DataModifyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataModifyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DataModifyReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DataModifyReturn, "xsd:string"))
				{	soap_flag__DataModifyReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataModifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataModifyResponse, SOAP_TYPE_ns1__DataModifyResponse, sizeof(struct ns1__DataModifyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataModifyResponse * SOAP_FMAC4 soap_new_ns1__DataModifyResponse(struct soap *soap, int n)
{
	struct ns1__DataModifyResponse *p;
	struct ns1__DataModifyResponse *a = (struct ns1__DataModifyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataModifyResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataModifyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataModifyResponse(struct soap *soap, const struct ns1__DataModifyResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataModifyResponse(soap, tag ? tag : "ns1:DataModifyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataModifyResponse * SOAP_FMAC4 soap_get_ns1__DataModifyResponse(struct soap *soap, struct ns1__DataModifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataModifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataCancel(struct soap *soap, struct ns1__DataCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataCancel(struct soap *soap, const struct ns1__DataCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataCancel(struct soap *soap, const char *tag, int id, const struct ns1__DataCancel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataCancel), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataCancel * SOAP_FMAC4 soap_in_ns1__DataCancel(struct soap *soap, const char *tag, struct ns1__DataCancel *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataCancel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataCancel, sizeof(struct ns1__DataCancel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataCancel(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataCancel, SOAP_TYPE_ns1__DataCancel, sizeof(struct ns1__DataCancel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataCancel * SOAP_FMAC4 soap_new_ns1__DataCancel(struct soap *soap, int n)
{
	struct ns1__DataCancel *p;
	struct ns1__DataCancel *a = (struct ns1__DataCancel*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataCancel));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataCancel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataCancel(struct soap *soap, const struct ns1__DataCancel *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataCancel(soap, tag ? tag : "ns1:DataCancel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataCancel * SOAP_FMAC4 soap_get_ns1__DataCancel(struct soap *soap, struct ns1__DataCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataCancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataCancelResponse(struct soap *soap, struct ns1__DataCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DataCancelReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataCancelResponse(struct soap *soap, const struct ns1__DataCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DataCancelReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataCancelResponse(struct soap *soap, const char *tag, int id, const struct ns1__DataCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataCancelResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DataCancelReturn", -1, &a->_DataCancelReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataCancelResponse * SOAP_FMAC4 soap_in_ns1__DataCancelResponse(struct soap *soap, const char *tag, struct ns1__DataCancelResponse *a, const char *type)
{
	size_t soap_flag__DataCancelReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataCancelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataCancelResponse, sizeof(struct ns1__DataCancelResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataCancelResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DataCancelReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DataCancelReturn, "xsd:string"))
				{	soap_flag__DataCancelReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataCancelResponse, SOAP_TYPE_ns1__DataCancelResponse, sizeof(struct ns1__DataCancelResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataCancelResponse * SOAP_FMAC4 soap_new_ns1__DataCancelResponse(struct soap *soap, int n)
{
	struct ns1__DataCancelResponse *p;
	struct ns1__DataCancelResponse *a = (struct ns1__DataCancelResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataCancelResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataCancelResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataCancelResponse(struct soap *soap, const struct ns1__DataCancelResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataCancelResponse(soap, tag ? tag : "ns1:DataCancelResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataCancelResponse * SOAP_FMAC4 soap_get_ns1__DataCancelResponse(struct soap *soap, struct ns1__DataCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftModify(struct soap *soap, struct ns1__SoftModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftModify(struct soap *soap, const struct ns1__SoftModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftModify(struct soap *soap, const char *tag, int id, const struct ns1__SoftModify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftModify), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftModify * SOAP_FMAC4 soap_in_ns1__SoftModify(struct soap *soap, const char *tag, struct ns1__SoftModify *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftModify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftModify, sizeof(struct ns1__SoftModify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftModify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftModify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftModify, SOAP_TYPE_ns1__SoftModify, sizeof(struct ns1__SoftModify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftModify * SOAP_FMAC4 soap_new_ns1__SoftModify(struct soap *soap, int n)
{
	struct ns1__SoftModify *p;
	struct ns1__SoftModify *a = (struct ns1__SoftModify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftModify));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftModify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftModify(struct soap *soap, const struct ns1__SoftModify *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftModify(soap, tag ? tag : "ns1:SoftModify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftModify * SOAP_FMAC4 soap_get_ns1__SoftModify(struct soap *soap, struct ns1__SoftModify *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftModify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftModifyResponse(struct soap *soap, struct ns1__SoftModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_SoftModifyReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftModifyResponse(struct soap *soap, const struct ns1__SoftModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_SoftModifyReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftModifyResponse(struct soap *soap, const char *tag, int id, const struct ns1__SoftModifyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftModifyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "SoftModifyReturn", -1, &a->_SoftModifyReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftModifyResponse * SOAP_FMAC4 soap_in_ns1__SoftModifyResponse(struct soap *soap, const char *tag, struct ns1__SoftModifyResponse *a, const char *type)
{
	size_t soap_flag__SoftModifyReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftModifyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftModifyResponse, sizeof(struct ns1__SoftModifyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftModifyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__SoftModifyReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_SoftModifyReturn, "xsd:string"))
				{	soap_flag__SoftModifyReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftModifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftModifyResponse, SOAP_TYPE_ns1__SoftModifyResponse, sizeof(struct ns1__SoftModifyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftModifyResponse * SOAP_FMAC4 soap_new_ns1__SoftModifyResponse(struct soap *soap, int n)
{
	struct ns1__SoftModifyResponse *p;
	struct ns1__SoftModifyResponse *a = (struct ns1__SoftModifyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftModifyResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftModifyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftModifyResponse(struct soap *soap, const struct ns1__SoftModifyResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftModifyResponse(soap, tag ? tag : "ns1:SoftModifyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftModifyResponse * SOAP_FMAC4 soap_get_ns1__SoftModifyResponse(struct soap *soap, struct ns1__SoftModifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftModifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftCancel(struct soap *soap, struct ns1__SoftCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftCancel(struct soap *soap, const struct ns1__SoftCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftCancel(struct soap *soap, const char *tag, int id, const struct ns1__SoftCancel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftCancel), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftCancel * SOAP_FMAC4 soap_in_ns1__SoftCancel(struct soap *soap, const char *tag, struct ns1__SoftCancel *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftCancel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftCancel, sizeof(struct ns1__SoftCancel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftCancel(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftCancel, SOAP_TYPE_ns1__SoftCancel, sizeof(struct ns1__SoftCancel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftCancel * SOAP_FMAC4 soap_new_ns1__SoftCancel(struct soap *soap, int n)
{
	struct ns1__SoftCancel *p;
	struct ns1__SoftCancel *a = (struct ns1__SoftCancel*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftCancel));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftCancel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftCancel(struct soap *soap, const struct ns1__SoftCancel *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftCancel(soap, tag ? tag : "ns1:SoftCancel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftCancel * SOAP_FMAC4 soap_get_ns1__SoftCancel(struct soap *soap, struct ns1__SoftCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftCancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftCancelResponse(struct soap *soap, struct ns1__SoftCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_SoftCancelReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftCancelResponse(struct soap *soap, const struct ns1__SoftCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_SoftCancelReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftCancelResponse(struct soap *soap, const char *tag, int id, const struct ns1__SoftCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftCancelResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "SoftCancelReturn", -1, &a->_SoftCancelReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftCancelResponse * SOAP_FMAC4 soap_in_ns1__SoftCancelResponse(struct soap *soap, const char *tag, struct ns1__SoftCancelResponse *a, const char *type)
{
	size_t soap_flag__SoftCancelReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftCancelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftCancelResponse, sizeof(struct ns1__SoftCancelResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftCancelResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__SoftCancelReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_SoftCancelReturn, "xsd:string"))
				{	soap_flag__SoftCancelReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftCancelResponse, SOAP_TYPE_ns1__SoftCancelResponse, sizeof(struct ns1__SoftCancelResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftCancelResponse * SOAP_FMAC4 soap_new_ns1__SoftCancelResponse(struct soap *soap, int n)
{
	struct ns1__SoftCancelResponse *p;
	struct ns1__SoftCancelResponse *a = (struct ns1__SoftCancelResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftCancelResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftCancelResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftCancelResponse(struct soap *soap, const struct ns1__SoftCancelResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftCancelResponse(soap, tag ? tag : "ns1:SoftCancelResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftCancelResponse * SOAP_FMAC4 soap_get_ns1__SoftCancelResponse(struct soap *soap, struct ns1__SoftCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceListGet(struct soap *soap, struct ns1__DeviceListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceListGet(struct soap *soap, const struct ns1__DeviceListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceListGet(struct soap *soap, const char *tag, int id, const struct ns1__DeviceListGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceListGet), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceListGet * SOAP_FMAC4 soap_in_ns1__DeviceListGet(struct soap *soap, const char *tag, struct ns1__DeviceListGet *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceListGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceListGet, sizeof(struct ns1__DeviceListGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceListGet(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceListGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceListGet, SOAP_TYPE_ns1__DeviceListGet, sizeof(struct ns1__DeviceListGet), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceListGet * SOAP_FMAC4 soap_new_ns1__DeviceListGet(struct soap *soap, int n)
{
	struct ns1__DeviceListGet *p;
	struct ns1__DeviceListGet *a = (struct ns1__DeviceListGet*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceListGet));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceListGet(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceListGet(struct soap *soap, const struct ns1__DeviceListGet *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceListGet(soap, tag ? tag : "ns1:DeviceListGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceListGet * SOAP_FMAC4 soap_get_ns1__DeviceListGet(struct soap *soap, struct ns1__DeviceListGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceListGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceListGetResponse(struct soap *soap, struct ns1__DeviceListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DeviceListGetReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceListGetResponse(struct soap *soap, const struct ns1__DeviceListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DeviceListGetReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceListGetResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeviceListGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceListGetResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DeviceListGetReturn", -1, &a->_DeviceListGetReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceListGetResponse * SOAP_FMAC4 soap_in_ns1__DeviceListGetResponse(struct soap *soap, const char *tag, struct ns1__DeviceListGetResponse *a, const char *type)
{
	size_t soap_flag__DeviceListGetReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceListGetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceListGetResponse, sizeof(struct ns1__DeviceListGetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceListGetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DeviceListGetReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DeviceListGetReturn, "xsd:string"))
				{	soap_flag__DeviceListGetReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceListGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceListGetResponse, SOAP_TYPE_ns1__DeviceListGetResponse, sizeof(struct ns1__DeviceListGetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceListGetResponse * SOAP_FMAC4 soap_new_ns1__DeviceListGetResponse(struct soap *soap, int n)
{
	struct ns1__DeviceListGetResponse *p;
	struct ns1__DeviceListGetResponse *a = (struct ns1__DeviceListGetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceListGetResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceListGetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceListGetResponse(struct soap *soap, const struct ns1__DeviceListGetResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceListGetResponse(soap, tag ? tag : "ns1:DeviceListGetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceListGetResponse * SOAP_FMAC4 soap_get_ns1__DeviceListGetResponse(struct soap *soap, struct ns1__DeviceListGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceListGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceModify(struct soap *soap, struct ns1__DeviceModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceModify(struct soap *soap, const struct ns1__DeviceModify *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceModify(struct soap *soap, const char *tag, int id, const struct ns1__DeviceModify *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceModify), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceModify * SOAP_FMAC4 soap_in_ns1__DeviceModify(struct soap *soap, const char *tag, struct ns1__DeviceModify *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceModify*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceModify, sizeof(struct ns1__DeviceModify), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceModify(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceModify *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceModify, SOAP_TYPE_ns1__DeviceModify, sizeof(struct ns1__DeviceModify), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceModify * SOAP_FMAC4 soap_new_ns1__DeviceModify(struct soap *soap, int n)
{
	struct ns1__DeviceModify *p;
	struct ns1__DeviceModify *a = (struct ns1__DeviceModify*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceModify));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceModify(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceModify(struct soap *soap, const struct ns1__DeviceModify *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceModify(soap, tag ? tag : "ns1:DeviceModify", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceModify * SOAP_FMAC4 soap_get_ns1__DeviceModify(struct soap *soap, struct ns1__DeviceModify *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceModify(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceModifyResponse(struct soap *soap, struct ns1__DeviceModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DeviceModifyReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceModifyResponse(struct soap *soap, const struct ns1__DeviceModifyResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DeviceModifyReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceModifyResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeviceModifyResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceModifyResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DeviceModifyReturn", -1, &a->_DeviceModifyReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceModifyResponse * SOAP_FMAC4 soap_in_ns1__DeviceModifyResponse(struct soap *soap, const char *tag, struct ns1__DeviceModifyResponse *a, const char *type)
{
	size_t soap_flag__DeviceModifyReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceModifyResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceModifyResponse, sizeof(struct ns1__DeviceModifyResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceModifyResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DeviceModifyReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DeviceModifyReturn, "xsd:string"))
				{	soap_flag__DeviceModifyReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceModifyResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceModifyResponse, SOAP_TYPE_ns1__DeviceModifyResponse, sizeof(struct ns1__DeviceModifyResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceModifyResponse * SOAP_FMAC4 soap_new_ns1__DeviceModifyResponse(struct soap *soap, int n)
{
	struct ns1__DeviceModifyResponse *p;
	struct ns1__DeviceModifyResponse *a = (struct ns1__DeviceModifyResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceModifyResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceModifyResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceModifyResponse(struct soap *soap, const struct ns1__DeviceModifyResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceModifyResponse(soap, tag ? tag : "ns1:DeviceModifyResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceModifyResponse * SOAP_FMAC4 soap_get_ns1__DeviceModifyResponse(struct soap *soap, struct ns1__DeviceModifyResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceModifyResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceCancel(struct soap *soap, struct ns1__DeviceCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceCancel(struct soap *soap, const struct ns1__DeviceCancel *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceCancel(struct soap *soap, const char *tag, int id, const struct ns1__DeviceCancel *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceCancel), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceCancel * SOAP_FMAC4 soap_in_ns1__DeviceCancel(struct soap *soap, const char *tag, struct ns1__DeviceCancel *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceCancel*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceCancel, sizeof(struct ns1__DeviceCancel), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceCancel(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceCancel *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceCancel, SOAP_TYPE_ns1__DeviceCancel, sizeof(struct ns1__DeviceCancel), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceCancel * SOAP_FMAC4 soap_new_ns1__DeviceCancel(struct soap *soap, int n)
{
	struct ns1__DeviceCancel *p;
	struct ns1__DeviceCancel *a = (struct ns1__DeviceCancel*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceCancel));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceCancel(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceCancel(struct soap *soap, const struct ns1__DeviceCancel *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceCancel(soap, tag ? tag : "ns1:DeviceCancel", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceCancel * SOAP_FMAC4 soap_get_ns1__DeviceCancel(struct soap *soap, struct ns1__DeviceCancel *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceCancel(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceCancelResponse(struct soap *soap, struct ns1__DeviceCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DeviceCancelReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceCancelResponse(struct soap *soap, const struct ns1__DeviceCancelResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DeviceCancelReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceCancelResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeviceCancelResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceCancelResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DeviceCancelReturn", -1, &a->_DeviceCancelReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceCancelResponse * SOAP_FMAC4 soap_in_ns1__DeviceCancelResponse(struct soap *soap, const char *tag, struct ns1__DeviceCancelResponse *a, const char *type)
{
	size_t soap_flag__DeviceCancelReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceCancelResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceCancelResponse, sizeof(struct ns1__DeviceCancelResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceCancelResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DeviceCancelReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DeviceCancelReturn, "xsd:string"))
				{	soap_flag__DeviceCancelReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceCancelResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceCancelResponse, SOAP_TYPE_ns1__DeviceCancelResponse, sizeof(struct ns1__DeviceCancelResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceCancelResponse * SOAP_FMAC4 soap_new_ns1__DeviceCancelResponse(struct soap *soap, int n)
{
	struct ns1__DeviceCancelResponse *p;
	struct ns1__DeviceCancelResponse *a = (struct ns1__DeviceCancelResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceCancelResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceCancelResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceCancelResponse(struct soap *soap, const struct ns1__DeviceCancelResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceCancelResponse(soap, tag ? tag : "ns1:DeviceCancelResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceCancelResponse * SOAP_FMAC4 soap_get_ns1__DeviceCancelResponse(struct soap *soap, struct ns1__DeviceCancelResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceCancelResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataDefine(struct soap *soap, struct ns1__DataDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataDefine(struct soap *soap, const struct ns1__DataDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataDefine(struct soap *soap, const char *tag, int id, const struct ns1__DataDefine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataDefine), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataDefine * SOAP_FMAC4 soap_in_ns1__DataDefine(struct soap *soap, const char *tag, struct ns1__DataDefine *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataDefine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataDefine, sizeof(struct ns1__DataDefine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataDefine(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataDefine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataDefine, SOAP_TYPE_ns1__DataDefine, sizeof(struct ns1__DataDefine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataDefine * SOAP_FMAC4 soap_new_ns1__DataDefine(struct soap *soap, int n)
{
	struct ns1__DataDefine *p;
	struct ns1__DataDefine *a = (struct ns1__DataDefine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataDefine));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataDefine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataDefine(struct soap *soap, const struct ns1__DataDefine *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataDefine(soap, tag ? tag : "ns1:DataDefine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataDefine * SOAP_FMAC4 soap_get_ns1__DataDefine(struct soap *soap, struct ns1__DataDefine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataDefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataDefineResponse(struct soap *soap, struct ns1__DataDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DataDefineReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataDefineResponse(struct soap *soap, const struct ns1__DataDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DataDefineReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataDefineResponse(struct soap *soap, const char *tag, int id, const struct ns1__DataDefineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataDefineResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DataDefineReturn", -1, &a->_DataDefineReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataDefineResponse * SOAP_FMAC4 soap_in_ns1__DataDefineResponse(struct soap *soap, const char *tag, struct ns1__DataDefineResponse *a, const char *type)
{
	size_t soap_flag__DataDefineReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataDefineResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataDefineResponse, sizeof(struct ns1__DataDefineResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataDefineResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DataDefineReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DataDefineReturn, "xsd:string"))
				{	soap_flag__DataDefineReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataDefineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataDefineResponse, SOAP_TYPE_ns1__DataDefineResponse, sizeof(struct ns1__DataDefineResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataDefineResponse * SOAP_FMAC4 soap_new_ns1__DataDefineResponse(struct soap *soap, int n)
{
	struct ns1__DataDefineResponse *p;
	struct ns1__DataDefineResponse *a = (struct ns1__DataDefineResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataDefineResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataDefineResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataDefineResponse(struct soap *soap, const struct ns1__DataDefineResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataDefineResponse(soap, tag ? tag : "ns1:DataDefineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataDefineResponse * SOAP_FMAC4 soap_get_ns1__DataDefineResponse(struct soap *soap, struct ns1__DataDefineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataDefineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataListGet(struct soap *soap, struct ns1__DataListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataListGet(struct soap *soap, const struct ns1__DataListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataListGet(struct soap *soap, const char *tag, int id, const struct ns1__DataListGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataListGet), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataListGet * SOAP_FMAC4 soap_in_ns1__DataListGet(struct soap *soap, const char *tag, struct ns1__DataListGet *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataListGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataListGet, sizeof(struct ns1__DataListGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataListGet(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataListGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataListGet, SOAP_TYPE_ns1__DataListGet, sizeof(struct ns1__DataListGet), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataListGet * SOAP_FMAC4 soap_new_ns1__DataListGet(struct soap *soap, int n)
{
	struct ns1__DataListGet *p;
	struct ns1__DataListGet *a = (struct ns1__DataListGet*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataListGet));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataListGet(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataListGet(struct soap *soap, const struct ns1__DataListGet *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataListGet(soap, tag ? tag : "ns1:DataListGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataListGet * SOAP_FMAC4 soap_get_ns1__DataListGet(struct soap *soap, struct ns1__DataListGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataListGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DataListGetResponse(struct soap *soap, struct ns1__DataListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DataListGetReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DataListGetResponse(struct soap *soap, const struct ns1__DataListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DataListGetReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DataListGetResponse(struct soap *soap, const char *tag, int id, const struct ns1__DataListGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DataListGetResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DataListGetReturn", -1, &a->_DataListGetReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DataListGetResponse * SOAP_FMAC4 soap_in_ns1__DataListGetResponse(struct soap *soap, const char *tag, struct ns1__DataListGetResponse *a, const char *type)
{
	size_t soap_flag__DataListGetReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DataListGetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DataListGetResponse, sizeof(struct ns1__DataListGetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DataListGetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DataListGetReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DataListGetReturn, "xsd:string"))
				{	soap_flag__DataListGetReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DataListGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DataListGetResponse, SOAP_TYPE_ns1__DataListGetResponse, sizeof(struct ns1__DataListGetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DataListGetResponse * SOAP_FMAC4 soap_new_ns1__DataListGetResponse(struct soap *soap, int n)
{
	struct ns1__DataListGetResponse *p;
	struct ns1__DataListGetResponse *a = (struct ns1__DataListGetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DataListGetResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DataListGetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DataListGetResponse(struct soap *soap, const struct ns1__DataListGetResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DataListGetResponse(soap, tag ? tag : "ns1:DataListGetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DataListGetResponse * SOAP_FMAC4 soap_get_ns1__DataListGetResponse(struct soap *soap, struct ns1__DataListGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DataListGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__Challenge(struct soap *soap, struct ns1__Challenge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__Challenge(struct soap *soap, const struct ns1__Challenge *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__Challenge(struct soap *soap, const char *tag, int id, const struct ns1__Challenge *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__Challenge), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__Challenge * SOAP_FMAC4 soap_in_ns1__Challenge(struct soap *soap, const char *tag, struct ns1__Challenge *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__Challenge*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__Challenge, sizeof(struct ns1__Challenge), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__Challenge(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__Challenge *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__Challenge, SOAP_TYPE_ns1__Challenge, sizeof(struct ns1__Challenge), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__Challenge * SOAP_FMAC4 soap_new_ns1__Challenge(struct soap *soap, int n)
{
	struct ns1__Challenge *p;
	struct ns1__Challenge *a = (struct ns1__Challenge*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__Challenge));
	for (p = a; p && n--; p++)
		soap_default_ns1__Challenge(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__Challenge(struct soap *soap, const struct ns1__Challenge *a, const char *tag, const char *type)
{
	if (soap_out_ns1__Challenge(soap, tag ? tag : "ns1:Challenge", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__Challenge * SOAP_FMAC4 soap_get_ns1__Challenge(struct soap *soap, struct ns1__Challenge *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__Challenge(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__ChallengeResponse(struct soap *soap, struct ns1__ChallengeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_ChallengeReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__ChallengeResponse(struct soap *soap, const struct ns1__ChallengeResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_ChallengeReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__ChallengeResponse(struct soap *soap, const char *tag, int id, const struct ns1__ChallengeResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__ChallengeResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "ChallengeReturn", -1, &a->_ChallengeReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__ChallengeResponse * SOAP_FMAC4 soap_in_ns1__ChallengeResponse(struct soap *soap, const char *tag, struct ns1__ChallengeResponse *a, const char *type)
{
	size_t soap_flag__ChallengeReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__ChallengeResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__ChallengeResponse, sizeof(struct ns1__ChallengeResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__ChallengeResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__ChallengeReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_ChallengeReturn, "xsd:string"))
				{	soap_flag__ChallengeReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__ChallengeResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__ChallengeResponse, SOAP_TYPE_ns1__ChallengeResponse, sizeof(struct ns1__ChallengeResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__ChallengeResponse * SOAP_FMAC4 soap_new_ns1__ChallengeResponse(struct soap *soap, int n)
{
	struct ns1__ChallengeResponse *p;
	struct ns1__ChallengeResponse *a = (struct ns1__ChallengeResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__ChallengeResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__ChallengeResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__ChallengeResponse(struct soap *soap, const struct ns1__ChallengeResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__ChallengeResponse(soap, tag ? tag : "ns1:ChallengeResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__ChallengeResponse * SOAP_FMAC4 soap_get_ns1__ChallengeResponse(struct soap *soap, struct ns1__ChallengeResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__ChallengeResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftDefine(struct soap *soap, struct ns1__SoftDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftDefine(struct soap *soap, const struct ns1__SoftDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftDefine(struct soap *soap, const char *tag, int id, const struct ns1__SoftDefine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftDefine), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftDefine * SOAP_FMAC4 soap_in_ns1__SoftDefine(struct soap *soap, const char *tag, struct ns1__SoftDefine *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftDefine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftDefine, sizeof(struct ns1__SoftDefine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftDefine(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftDefine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftDefine, SOAP_TYPE_ns1__SoftDefine, sizeof(struct ns1__SoftDefine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftDefine * SOAP_FMAC4 soap_new_ns1__SoftDefine(struct soap *soap, int n)
{
	struct ns1__SoftDefine *p;
	struct ns1__SoftDefine *a = (struct ns1__SoftDefine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftDefine));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftDefine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftDefine(struct soap *soap, const struct ns1__SoftDefine *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftDefine(soap, tag ? tag : "ns1:SoftDefine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftDefine * SOAP_FMAC4 soap_get_ns1__SoftDefine(struct soap *soap, struct ns1__SoftDefine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftDefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftDefineResponse(struct soap *soap, struct ns1__SoftDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_SoftDefineReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftDefineResponse(struct soap *soap, const struct ns1__SoftDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_SoftDefineReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftDefineResponse(struct soap *soap, const char *tag, int id, const struct ns1__SoftDefineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftDefineResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "SoftDefineReturn", -1, &a->_SoftDefineReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftDefineResponse * SOAP_FMAC4 soap_in_ns1__SoftDefineResponse(struct soap *soap, const char *tag, struct ns1__SoftDefineResponse *a, const char *type)
{
	size_t soap_flag__SoftDefineReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftDefineResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftDefineResponse, sizeof(struct ns1__SoftDefineResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftDefineResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__SoftDefineReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_SoftDefineReturn, "xsd:string"))
				{	soap_flag__SoftDefineReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftDefineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftDefineResponse, SOAP_TYPE_ns1__SoftDefineResponse, sizeof(struct ns1__SoftDefineResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftDefineResponse * SOAP_FMAC4 soap_new_ns1__SoftDefineResponse(struct soap *soap, int n)
{
	struct ns1__SoftDefineResponse *p;
	struct ns1__SoftDefineResponse *a = (struct ns1__SoftDefineResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftDefineResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftDefineResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftDefineResponse(struct soap *soap, const struct ns1__SoftDefineResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftDefineResponse(soap, tag ? tag : "ns1:SoftDefineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftDefineResponse * SOAP_FMAC4 soap_get_ns1__SoftDefineResponse(struct soap *soap, struct ns1__SoftDefineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftDefineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftListGet(struct soap *soap, struct ns1__SoftListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftListGet(struct soap *soap, const struct ns1__SoftListGet *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftListGet(struct soap *soap, const char *tag, int id, const struct ns1__SoftListGet *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftListGet), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftListGet * SOAP_FMAC4 soap_in_ns1__SoftListGet(struct soap *soap, const char *tag, struct ns1__SoftListGet *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftListGet*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftListGet, sizeof(struct ns1__SoftListGet), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftListGet(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftListGet *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftListGet, SOAP_TYPE_ns1__SoftListGet, sizeof(struct ns1__SoftListGet), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftListGet * SOAP_FMAC4 soap_new_ns1__SoftListGet(struct soap *soap, int n)
{
	struct ns1__SoftListGet *p;
	struct ns1__SoftListGet *a = (struct ns1__SoftListGet*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftListGet));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftListGet(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftListGet(struct soap *soap, const struct ns1__SoftListGet *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftListGet(soap, tag ? tag : "ns1:SoftListGet", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftListGet * SOAP_FMAC4 soap_get_ns1__SoftListGet(struct soap *soap, struct ns1__SoftListGet *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftListGet(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__SoftListGetResponse(struct soap *soap, struct ns1__SoftListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_SoftListGetReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__SoftListGetResponse(struct soap *soap, const struct ns1__SoftListGetResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_SoftListGetReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__SoftListGetResponse(struct soap *soap, const char *tag, int id, const struct ns1__SoftListGetResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__SoftListGetResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "SoftListGetReturn", -1, &a->_SoftListGetReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__SoftListGetResponse * SOAP_FMAC4 soap_in_ns1__SoftListGetResponse(struct soap *soap, const char *tag, struct ns1__SoftListGetResponse *a, const char *type)
{
	size_t soap_flag__SoftListGetReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__SoftListGetResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__SoftListGetResponse, sizeof(struct ns1__SoftListGetResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__SoftListGetResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__SoftListGetReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_SoftListGetReturn, "xsd:string"))
				{	soap_flag__SoftListGetReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__SoftListGetResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__SoftListGetResponse, SOAP_TYPE_ns1__SoftListGetResponse, sizeof(struct ns1__SoftListGetResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__SoftListGetResponse * SOAP_FMAC4 soap_new_ns1__SoftListGetResponse(struct soap *soap, int n)
{
	struct ns1__SoftListGetResponse *p;
	struct ns1__SoftListGetResponse *a = (struct ns1__SoftListGetResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__SoftListGetResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__SoftListGetResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__SoftListGetResponse(struct soap *soap, const struct ns1__SoftListGetResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__SoftListGetResponse(soap, tag ? tag : "ns1:SoftListGetResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__SoftListGetResponse * SOAP_FMAC4 soap_get_ns1__SoftListGetResponse(struct soap *soap, struct ns1__SoftListGetResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__SoftListGetResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceDefine(struct soap *soap, struct ns1__DeviceDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	soap_default_string(soap, &a->_inStr);
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceDefine(struct soap *soap, const struct ns1__DeviceDefine *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_string(soap, (char*const*)&a->_inStr);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceDefine(struct soap *soap, const char *tag, int id, const struct ns1__DeviceDefine *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceDefine), type))
		return soap->error;
	if (soap_out_string(soap, "inStr", -1, (char*const*)&a->_inStr, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceDefine * SOAP_FMAC4 soap_in_ns1__DeviceDefine(struct soap *soap, const char *tag, struct ns1__DeviceDefine *a, const char *type)
{
	size_t soap_flag__inStr = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceDefine*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceDefine, sizeof(struct ns1__DeviceDefine), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceDefine(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__inStr && (soap->error == SOAP_TAG_MISMATCH || soap->error == SOAP_NO_TAG))
			{	if (soap_in_string(soap, NULL, (char**)&a->_inStr, "xsd:string"))
				{	soap_flag__inStr--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceDefine *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceDefine, SOAP_TYPE_ns1__DeviceDefine, sizeof(struct ns1__DeviceDefine), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceDefine * SOAP_FMAC4 soap_new_ns1__DeviceDefine(struct soap *soap, int n)
{
	struct ns1__DeviceDefine *p;
	struct ns1__DeviceDefine *a = (struct ns1__DeviceDefine*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceDefine));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceDefine(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceDefine(struct soap *soap, const struct ns1__DeviceDefine *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceDefine(soap, tag ? tag : "ns1:DeviceDefine", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceDefine * SOAP_FMAC4 soap_get_ns1__DeviceDefine(struct soap *soap, struct ns1__DeviceDefine *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceDefine(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__DeviceDefineResponse(struct soap *soap, struct ns1__DeviceDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->_DeviceDefineReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__DeviceDefineResponse(struct soap *soap, const struct ns1__DeviceDefineResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->_DeviceDefineReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__DeviceDefineResponse(struct soap *soap, const char *tag, int id, const struct ns1__DeviceDefineResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__DeviceDefineResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "DeviceDefineReturn", -1, &a->_DeviceDefineReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__DeviceDefineResponse * SOAP_FMAC4 soap_in_ns1__DeviceDefineResponse(struct soap *soap, const char *tag, struct ns1__DeviceDefineResponse *a, const char *type)
{
	size_t soap_flag__DeviceDefineReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__DeviceDefineResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__DeviceDefineResponse, sizeof(struct ns1__DeviceDefineResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__DeviceDefineResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag__DeviceDefineReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, NULL, &a->_DeviceDefineReturn, "xsd:string"))
				{	soap_flag__DeviceDefineReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__DeviceDefineResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__DeviceDefineResponse, SOAP_TYPE_ns1__DeviceDefineResponse, sizeof(struct ns1__DeviceDefineResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__DeviceDefineResponse * SOAP_FMAC4 soap_new_ns1__DeviceDefineResponse(struct soap *soap, int n)
{
	struct ns1__DeviceDefineResponse *p;
	struct ns1__DeviceDefineResponse *a = (struct ns1__DeviceDefineResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__DeviceDefineResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__DeviceDefineResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__DeviceDefineResponse(struct soap *soap, const struct ns1__DeviceDefineResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__DeviceDefineResponse(soap, tag ? tag : "ns1:DeviceDefineResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__DeviceDefineResponse * SOAP_FMAC4 soap_get_ns1__DeviceDefineResponse(struct soap *soap, struct ns1__DeviceDefineResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__DeviceDefineResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDeviceBatch(struct soap *soap, struct ns1__addDeviceBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDeviceBatch(struct soap *soap, const struct ns1__addDeviceBatch *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDeviceBatch(struct soap *soap, const char *tag, int id, const struct ns1__addDeviceBatch *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDeviceBatch), type))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDeviceBatch * SOAP_FMAC4 soap_in_ns1__addDeviceBatch(struct soap *soap, const char *tag, struct ns1__addDeviceBatch *a, const char *type)
{
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDeviceBatch*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDeviceBatch, sizeof(struct ns1__addDeviceBatch), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDeviceBatch(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDeviceBatch *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDeviceBatch, SOAP_TYPE_ns1__addDeviceBatch, sizeof(struct ns1__addDeviceBatch), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__addDeviceBatch * SOAP_FMAC4 soap_new_ns1__addDeviceBatch(struct soap *soap, int n)
{
	struct ns1__addDeviceBatch *p;
	struct ns1__addDeviceBatch *a = (struct ns1__addDeviceBatch*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__addDeviceBatch));
	for (p = a; p && n--; p++)
		soap_default_ns1__addDeviceBatch(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDeviceBatch(struct soap *soap, const struct ns1__addDeviceBatch *a, const char *tag, const char *type)
{
	if (soap_out_ns1__addDeviceBatch(soap, tag ? tag : "ns1:addDeviceBatch", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDeviceBatch * SOAP_FMAC4 soap_get_ns1__addDeviceBatch(struct soap *soap, struct ns1__addDeviceBatch *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDeviceBatch(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_default_ns1__addDeviceBatchResponse(struct soap *soap, struct ns1__addDeviceBatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
	a->addDeviceBatchReturn = NULL;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_ns1__addDeviceBatchResponse(struct soap *soap, const struct ns1__addDeviceBatchResponse *a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	soap_serialize_PointerTostring(soap, &a->addDeviceBatchReturn);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_ns1__addDeviceBatchResponse(struct soap *soap, const char *tag, int id, const struct ns1__addDeviceBatchResponse *a, const char *type)
{
	(void)soap; (void)tag; (void)id; (void)a; (void)type; /* appease -Wall -Werror */
	if (soap_element_begin_out(soap, tag, soap_embedded_id(soap, id, a, SOAP_TYPE_ns1__addDeviceBatchResponse), type))
		return soap->error;
	if (soap_out_PointerTostring(soap, "addDeviceBatchReturn", -1, &a->addDeviceBatchReturn, ""))
		return soap->error;
	return soap_element_end_out(soap, tag);
}

SOAP_FMAC3 struct ns1__addDeviceBatchResponse * SOAP_FMAC4 soap_in_ns1__addDeviceBatchResponse(struct soap *soap, const char *tag, struct ns1__addDeviceBatchResponse *a, const char *type)
{
	size_t soap_flag_addDeviceBatchReturn = 1;
	if (soap_element_begin_in(soap, tag, 0, type))
		return NULL;
	a = (struct ns1__addDeviceBatchResponse*)soap_id_enter(soap, soap->id, a, SOAP_TYPE_ns1__addDeviceBatchResponse, sizeof(struct ns1__addDeviceBatchResponse), NULL, NULL, NULL, NULL);
	if (!a)
		return NULL;
	soap_default_ns1__addDeviceBatchResponse(soap, a);
	if (soap->body && *soap->href != '#')
	{
		for (;;)
		{	soap->error = SOAP_TAG_MISMATCH;
			if (soap_flag_addDeviceBatchReturn && soap->error == SOAP_TAG_MISMATCH)
			{	if (soap_in_PointerTostring(soap, "addDeviceBatchReturn", &a->addDeviceBatchReturn, "xsd:string"))
				{	soap_flag_addDeviceBatchReturn--;
					continue;
				}
			}
			if (soap->error == SOAP_TAG_MISMATCH)
				soap->error = soap_ignore_element(soap);
			if (soap->error == SOAP_NO_TAG)
				break;
			if (soap->error)
				return NULL;
		}
		if (soap_element_end_in(soap, tag))
			return NULL;
	}
	else
	{	a = (struct ns1__addDeviceBatchResponse *)soap_id_forward(soap, soap->href, (void*)a, 0, SOAP_TYPE_ns1__addDeviceBatchResponse, SOAP_TYPE_ns1__addDeviceBatchResponse, sizeof(struct ns1__addDeviceBatchResponse), 0, NULL, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 struct ns1__addDeviceBatchResponse * SOAP_FMAC4 soap_new_ns1__addDeviceBatchResponse(struct soap *soap, int n)
{
	struct ns1__addDeviceBatchResponse *p;
	struct ns1__addDeviceBatchResponse *a = (struct ns1__addDeviceBatchResponse*)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(struct ns1__addDeviceBatchResponse));
	for (p = a; p && n--; p++)
		soap_default_ns1__addDeviceBatchResponse(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_ns1__addDeviceBatchResponse(struct soap *soap, const struct ns1__addDeviceBatchResponse *a, const char *tag, const char *type)
{
	if (soap_out_ns1__addDeviceBatchResponse(soap, tag ? tag : "ns1:addDeviceBatchResponse", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct ns1__addDeviceBatchResponse * SOAP_FMAC4 soap_get_ns1__addDeviceBatchResponse(struct soap *soap, struct ns1__addDeviceBatchResponse *p, const char *tag, const char *type)
{
	if ((p = soap_in_ns1__addDeviceBatchResponse(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Reason))
		soap_serialize_SOAP_ENV__Reason(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Reason *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Reason, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Reason(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Reason(struct soap *soap, const char *tag, struct SOAP_ENV__Reason **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Reason **)soap_malloc(soap, sizeof(struct SOAP_ENV__Reason *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Reason(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Reason **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Reason, sizeof(struct SOAP_ENV__Reason), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Reason(soap, tag ? tag : "SOAP-ENV:Reason", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Reason ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Reason(struct soap *soap, struct SOAP_ENV__Reason **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Reason(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Detail))
		soap_serialize_SOAP_ENV__Detail(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Detail *const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Detail, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_SOAP_ENV__Detail(soap, tag, id, *a, type);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Detail(struct soap *soap, const char *tag, struct SOAP_ENV__Detail **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Detail **)soap_malloc(soap, sizeof(struct SOAP_ENV__Detail *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Detail(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Detail **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Detail, sizeof(struct SOAP_ENV__Detail), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Detail(soap, tag ? tag : "SOAP-ENV:Detail", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Detail ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Detail(struct soap *soap, struct SOAP_ENV__Detail **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Detail(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

#ifndef WITH_NOGLOBAL

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_SOAP_ENV__Code))
		soap_serialize_SOAP_ENV__Code(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, int id, struct SOAP_ENV__Code *const*a, const char *type)
{
	char *mark;
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_SOAP_ENV__Code, &mark);
	if (id < 0)
		return soap->error;
	(void)soap_out_SOAP_ENV__Code(soap, tag, id, *a, type);
	soap_unmark(soap, mark);
	return soap->error;
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_in_PointerToSOAP_ENV__Code(struct soap *soap, const char *tag, struct SOAP_ENV__Code **a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (struct SOAP_ENV__Code **)soap_malloc(soap, sizeof(struct SOAP_ENV__Code *))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_SOAP_ENV__Code(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (struct SOAP_ENV__Code **)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_SOAP_ENV__Code, sizeof(struct SOAP_ENV__Code), 0, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code *const*a, const char *tag, const char *type)
{
	if (soap_out_PointerToSOAP_ENV__Code(soap, tag ? tag : "SOAP-ENV:Code", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 struct SOAP_ENV__Code ** SOAP_FMAC4 soap_get_PointerToSOAP_ENV__Code(struct soap *soap, struct SOAP_ENV__Code **p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerToSOAP_ENV__Code(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#endif

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_PointerTostring(struct soap *soap, char **const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	if (!soap_reference(soap, *a, SOAP_TYPE_string))
		soap_serialize_string(soap, *a);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_PointerTostring(struct soap *soap, const char *tag, int id, char **const*a, const char *type)
{
	id = soap_element_id(soap, tag, id, *a, NULL, 0, type, SOAP_TYPE_string, NULL);
	if (id < 0)
		return soap->error;
	return soap_out_string(soap, tag, id, *a, type);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_in_PointerTostring(struct soap *soap, const char *tag, char ***a, const char *type)
{
	(void)type; /* appease -Wall -Werror */
	if (soap_element_begin_in(soap, tag, 1, NULL))
		return NULL;
	if (!a)
		if (!(a = (char ***)soap_malloc(soap, sizeof(char **))))
			return NULL;
	*a = NULL;
	if (!soap->null && *soap->href != '#')
	{	soap_revert(soap);
		if (!(*a = soap_in_string(soap, tag, *a, type)))
			return NULL;
	}
	else
	{	a = (char ***)soap_id_lookup(soap, soap->href, (void**)a, SOAP_TYPE_string, sizeof(char *), 1, NULL);
		if (soap->body && soap_element_end_in(soap, tag))
			return NULL;
	}
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_PointerTostring(struct soap *soap, char **const*a, const char *tag, const char *type)
{
	if (soap_out_PointerTostring(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char *** SOAP_FMAC4 soap_get_PointerTostring(struct soap *soap, char ***p, const char *tag, const char *type)
{
	if ((p = soap_in_PointerTostring(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize__QName(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE__QName);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out__QName(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE__QName);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in__QName(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE__QName, 2, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put__QName(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out__QName(soap, tag ? tag : "QName", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get__QName(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in__QName(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

SOAP_FMAC3 void SOAP_FMAC4 soap_serialize_string(struct soap *soap, char *const*a)
{
	(void)soap; (void)a; /* appease -Wall -Werror */
#ifndef WITH_NOIDREF
	(void)soap_reference(soap, *a, SOAP_TYPE_string);
#endif
}

SOAP_FMAC3 int SOAP_FMAC4 soap_out_string(struct soap *soap, const char *tag, int id, char *const*a, const char *type)
{
	return soap_outstring(soap, tag, id, a, type, SOAP_TYPE_string);
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_in_string(struct soap *soap, const char *tag, char **a, const char *type)
{
	a = soap_instring(soap, tag, a, type, SOAP_TYPE_string, 1, 0, -1, NULL);
	return a;
}

SOAP_FMAC3 char * * SOAP_FMAC4 soap_new_string(struct soap *soap, int n)
{
	char * *p;
	char * *a = (char **)soap_malloc((soap), (n = (n < 0 ? 1 : n)) * sizeof(char *));
	for (p = a; p && n--; p++)
		soap_default_string(soap, p);
	return a;
}

SOAP_FMAC3 int SOAP_FMAC4 soap_put_string(struct soap *soap, char *const*a, const char *tag, const char *type)
{
	if (soap_out_string(soap, tag ? tag : "string", -2, a, type))
		return soap->error;
	return soap_putindependent(soap);
}

SOAP_FMAC3 char ** SOAP_FMAC4 soap_get_string(struct soap *soap, char **p, const char *tag, const char *type)
{
	if ((p = soap_in_string(soap, tag, p, type)))
		if (soap_getindependent(soap))
			return NULL;
	return p;
}

#ifdef __cplusplus
}
#endif

#if defined(__BORLANDC__)
#pragma option pop
#pragma option pop
#endif

/* End of soapC.c */
